{
    "docs": [
        {
            "location": "/",
            "text": "github-heroku-attack-rabbits\n\n\nWhat's this business all about, then?\n\n\nThis repository helps you put access control into place to protect your secret pages by (deep breath):\n\n\nhosting your secret page of static and/or dynamic content by using a free Heroku app \nrunning a Python Flask server that uses Flask-Dance to authenticate visitors \nwith Github using OAuth which allows you fine-grained access control for your pages\nusing user attributes like organization or team membership or even things like how many\nvowels a user has in their username. \n\n\nAlso, did I mention the attack rabbits?\n\n\n\n\nWhere is everything?\n\n\nFinal pages:\n\n\n\n\n\n\nThe finished product (pages on Heroku protected by attack rabbits) \n    is at \ngithub-heroku-attack-rabbits.herokuapp.com\n\n\n\n\n\n\nThe documentation is at \npages.charlesreid1.com/github-heroku-attack-rabbits\n\n\n\n\n\n\nTwo branches in this repo compose the github-heroku-attack-rabbits documentation:\n\n\n\n\n\n\n(\nYOU ARE HERE\n) The \ndocs\n\n    branch contains the files needed to generate the \n    \ngithub-heroku-attack-rabbits documentation site\n.\n\n\n\n\n\n\nThe \ngh-pages\n\n    branch contains the static files generated from the documentation.\n    The contents of this branch compose the \n    \ngithub-heroku-attack-rabbits documentation site\n.\n\n\n\n\n\n\nTwo branches illustrate github-heroku-attack-rabbits in practice:\n\n\n\n\n\n\nThe \nsecret\n\n    branch contains the files needed to create the secret page. (This is the\n    \"secret page source branch\", so to speak.)\n    This repository, the one you are looking at right now, is public, so of course\n    these will not really be secret, but in practice the \nsecret\n branch would\n    live in a private repository.\n\n\n\n\n\n\nThe \nheroku-pages\n\n    branch contains the content that is actually pushed to Heroku - that is, \n    the final Flask app. This includes the Flask app (Python program), in\n    addition to files that tell Heroku how to run the app,\n    plus gunicorn \"middleware\" scripts, plus the static content that \n    Flask is supposed to serve up (whatever that happens to be - in our case,\n    we will cover an mkdocs documentation site that is behind an authentication\n    layer.).\n\n\n\n\n\n\nContents\n\n\nAn overview of the steps:\n\n\nGet Started with Heroku\n\n\nGet Started with Github\n\n\nInitialize Repository: Branches\n\n\nCreate a Flask App using Flask-Dance\n\n\n\n\nAuthenticate users based on Github membership only\n\n\nAuthenticate users based on organization or team membership\n\n\nAuthenticate users based on some other criteria\n\n\nProtection portions of the site\n\n\n\n\nTest Flask App Locally\n\n\nDeploying Flask App to Heroku\n\n\nCustom Domains\n\n\nLinks\n\n\nPython software used:\n\n\n\n\nFlask\n\n\nFlask-dance\n\n\nFlask-dance-github\n\n\nmkdocs-material (documentation theme)\n\n\nmkdocs (documentation)\n\n\n\n\nCommercial services:\n\n\n\n\nHeroku\n\n\nGithub\n\n\n\n\nLicense\n\n\nThis is released under the \nWTFPL\n.",
            "title": "Index"
        },
        {
            "location": "/#github-heroku-attack-rabbits",
            "text": "",
            "title": "github-heroku-attack-rabbits"
        },
        {
            "location": "/#whats-this-business-all-about-then",
            "text": "This repository helps you put access control into place to protect your secret pages by (deep breath):  hosting your secret page of static and/or dynamic content by using a free Heroku app \nrunning a Python Flask server that uses Flask-Dance to authenticate visitors \nwith Github using OAuth which allows you fine-grained access control for your pages\nusing user attributes like organization or team membership or even things like how many\nvowels a user has in their username.   Also, did I mention the attack rabbits?",
            "title": "What's this business all about, then?"
        },
        {
            "location": "/#where-is-everything",
            "text": "Final pages:    The finished product (pages on Heroku protected by attack rabbits) \n    is at  github-heroku-attack-rabbits.herokuapp.com    The documentation is at  pages.charlesreid1.com/github-heroku-attack-rabbits    Two branches in this repo compose the github-heroku-attack-rabbits documentation:    ( YOU ARE HERE ) The  docs \n    branch contains the files needed to generate the \n     github-heroku-attack-rabbits documentation site .    The  gh-pages \n    branch contains the static files generated from the documentation.\n    The contents of this branch compose the \n     github-heroku-attack-rabbits documentation site .    Two branches illustrate github-heroku-attack-rabbits in practice:    The  secret \n    branch contains the files needed to create the secret page. (This is the\n    \"secret page source branch\", so to speak.)\n    This repository, the one you are looking at right now, is public, so of course\n    these will not really be secret, but in practice the  secret  branch would\n    live in a private repository.    The  heroku-pages \n    branch contains the content that is actually pushed to Heroku - that is, \n    the final Flask app. This includes the Flask app (Python program), in\n    addition to files that tell Heroku how to run the app,\n    plus gunicorn \"middleware\" scripts, plus the static content that \n    Flask is supposed to serve up (whatever that happens to be - in our case,\n    we will cover an mkdocs documentation site that is behind an authentication\n    layer.).",
            "title": "Where is everything?"
        },
        {
            "location": "/#contents",
            "text": "An overview of the steps:  Get Started with Heroku  Get Started with Github  Initialize Repository: Branches  Create a Flask App using Flask-Dance   Authenticate users based on Github membership only  Authenticate users based on organization or team membership  Authenticate users based on some other criteria  Protection portions of the site   Test Flask App Locally  Deploying Flask App to Heroku  Custom Domains",
            "title": "Contents"
        },
        {
            "location": "/#links",
            "text": "Python software used:   Flask  Flask-dance  Flask-dance-github  mkdocs-material (documentation theme)  mkdocs (documentation)   Commercial services:   Heroku  Github",
            "title": "Links"
        },
        {
            "location": "/#license",
            "text": "This is released under the  WTFPL .",
            "title": "License"
        },
        {
            "location": "/heroku/",
            "text": "Create a Heroku app\n\n\nBefore you begin: install Heroku toolbelt\n\n\nHeroku offers a really nice command line interface tool called\nHeroku Toolbelt. It is available through Homebrew and Aptitude:\n\n\n$ brew install Heroku   # from Mac\n\n$ apt-get install Heroku    # from Ubuntu\n\n\n\n\nIt will then be available on the command line as \nHeroku\n.\n\n\nThe first thing you should do is authenticate with\nyour Heroku account by running\n\n\n$ heroku login\n\n\n\n\nWe will use this command line application for the following tasks:\n\n\n\n\nCreate a git remote to point to the right Heroku git remote location\n\n\nSet environment variables (for e.g. secret keys) on the remote Heroku instance\n\n\nGet information (logs, status, etc.) about your Heroku app\n\n\n\n\nWe will cover these commands as they come up.\n\n\nCreating a Heroku app\n\n\nStart by creating a Heroku app.\n\n\n\n\nEach Heroku app must have a unique name\n\n\nEach Heroku app creates a remote git repo\n\n\nMaster branch is what Heroku deploys publicly on Herokuapps.com\n\n\nYou will also need Heroku CLI to link your github repo to your Heroku app\n\n\n\n\nWhere Heroku apps live\n\n\nSuppose you are creating an app called \nmy-cool-app\n\non Heroku. Then your application will be hosted by \nHeroku and will be available at the URL:\n\n\nhttps://my-cool-app.herokuapp.com\n\n\n\n\nHow Heroku apps work\n\n\nIf you have used Github Pages before, Heroku uses a similar\nmodel (live hosting one particular branch of a git repository).\nHowever, Heroku is different because you can run dynamic scripts\nusing Python, Ruby, PHP, etc.\n\n\nTo change the content of your Heroku app, just change the contents\nof the repository, and push to master (push to the master branch of\nthe remote Heroku repository).\n\n\nYou will need to structure your repository carefully.\nThat's what this page is here to help you do.\nHeroku can figure out the rest from there.",
            "title": "Get Started with Heroku"
        },
        {
            "location": "/heroku/#create-a-heroku-app",
            "text": "",
            "title": "Create a Heroku app"
        },
        {
            "location": "/heroku/#before-you-begin-install-heroku-toolbelt",
            "text": "Heroku offers a really nice command line interface tool called\nHeroku Toolbelt. It is available through Homebrew and Aptitude:  $ brew install Heroku   # from Mac\n\n$ apt-get install Heroku    # from Ubuntu  It will then be available on the command line as  Heroku .  The first thing you should do is authenticate with\nyour Heroku account by running  $ heroku login  We will use this command line application for the following tasks:   Create a git remote to point to the right Heroku git remote location  Set environment variables (for e.g. secret keys) on the remote Heroku instance  Get information (logs, status, etc.) about your Heroku app   We will cover these commands as they come up.",
            "title": "Before you begin: install Heroku toolbelt"
        },
        {
            "location": "/heroku/#creating-a-heroku-app",
            "text": "Start by creating a Heroku app.   Each Heroku app must have a unique name  Each Heroku app creates a remote git repo  Master branch is what Heroku deploys publicly on Herokuapps.com  You will also need Heroku CLI to link your github repo to your Heroku app",
            "title": "Creating a Heroku app"
        },
        {
            "location": "/heroku/#where-heroku-apps-live",
            "text": "Suppose you are creating an app called  my-cool-app \non Heroku. Then your application will be hosted by \nHeroku and will be available at the URL:  https://my-cool-app.herokuapp.com",
            "title": "Where Heroku apps live"
        },
        {
            "location": "/heroku/#how-heroku-apps-work",
            "text": "If you have used Github Pages before, Heroku uses a similar\nmodel (live hosting one particular branch of a git repository).\nHowever, Heroku is different because you can run dynamic scripts\nusing Python, Ruby, PHP, etc.  To change the content of your Heroku app, just change the contents\nof the repository, and push to master (push to the master branch of\nthe remote Heroku repository).  You will need to structure your repository carefully.\nThat's what this page is here to help you do.\nHeroku can figure out the rest from there.",
            "title": "How Heroku apps work"
        },
        {
            "location": "/github/",
            "text": "Get started with Github\n\n\nWe mentioned on the \nheroku\n page that heroku\ncreates a remote git repository to hold the files you \nwant to host.\n\n\nTo use the contents of a Github repository on Heroku,\njust treat it like another git remote, no special setup\nis needed.\n\n\nHowever, to set up your Github-Heroku attack rabbits to \nauthenticate a user via Github, and mercilessly attack\nall intruders, you must create a Github OAuth App.\n\n\nCreating Github OAuth App\n\n\nLog into Github\n\n\nGo to Settings\n\n\nClick \"Developer Settings\" on the left side\n\n\nClick  \"New OAuth App\" button in upper right\n\n\nWhat do these settings mean?\n\n\n\n\n\n\nApplication name\n is what will be shown to users when they visit\n    a page protected by the attack rabbits and are prompted for\n    their password by Github.\n\n\n\n\n\n\nHomepage URL/Application description\n are for users who want to know more \n    about your killer attack rabbit Github app\n\n\n\n\n\n\nAuthorization callback URL\n is the URL that the users will be sent to\n    once they authenticate with Github and they are granted an OAuth token.\n    This is the magic ingredient that allows you to take actions on behalf\n    of the account logging in.\n\n\n\n\n\n\nIn this guide we'll cover the case of checking membership in organizations or teams,\nbut what your attack rabbits end up doing to determine if a user is allowed to\naccess your secret pages is up to you.\n\n\nValues to use\n\n\nYou should set your own values for the \nname\n and \ndescription\n fields.\n\n\nThe \nhome URL\n is not actually necessary - it is simply provided for users to\nget more information about your app.\n\n\nThe most important is the \ncallback URL\n, which should be set to:\n\n\nhttp://localhost:5000/login/github/authorized\n\n\n\n\nThis is for testing locally \nonly\n.\n\n\nDon't use HTTPS in the callback URL!",
            "title": "Get Started with Github"
        },
        {
            "location": "/github/#get-started-with-github",
            "text": "We mentioned on the  heroku  page that heroku\ncreates a remote git repository to hold the files you \nwant to host.  To use the contents of a Github repository on Heroku,\njust treat it like another git remote, no special setup\nis needed.  However, to set up your Github-Heroku attack rabbits to \nauthenticate a user via Github, and mercilessly attack\nall intruders, you must create a Github OAuth App.",
            "title": "Get started with Github"
        },
        {
            "location": "/github/#creating-github-oauth-app",
            "text": "Log into Github  Go to Settings  Click \"Developer Settings\" on the left side  Click  \"New OAuth App\" button in upper right  What do these settings mean?    Application name  is what will be shown to users when they visit\n    a page protected by the attack rabbits and are prompted for\n    their password by Github.    Homepage URL/Application description  are for users who want to know more \n    about your killer attack rabbit Github app    Authorization callback URL  is the URL that the users will be sent to\n    once they authenticate with Github and they are granted an OAuth token.\n    This is the magic ingredient that allows you to take actions on behalf\n    of the account logging in.    In this guide we'll cover the case of checking membership in organizations or teams,\nbut what your attack rabbits end up doing to determine if a user is allowed to\naccess your secret pages is up to you.",
            "title": "Creating Github OAuth App"
        },
        {
            "location": "/github/#values-to-use",
            "text": "You should set your own values for the  name  and  description  fields.  The  home URL  is not actually necessary - it is simply provided for users to\nget more information about your app.  The most important is the  callback URL , which should be set to:  http://localhost:5000/login/github/authorized  This is for testing locally  only .  Don't use HTTPS in the callback URL!",
            "title": "Values to use"
        },
        {
            "location": "/repo/",
            "text": "Initialize Git Repository\n\n\nLet's talk through how a repository should be laid out \nif we're going to be hosting a Flask app on Heroku.\n\n\nBranches\n\n\nWe will need a minimum of two branches. Here we specify\nthe names that these branches will have in your Github repo,\n\nwhich is different from the names of the branches on Heroku\n:\n\n\nBranches on Github:\n\n\n\n\n\n\nheroku-pages\n - this branch contains the content that Heroku will host.\n    Specifically, it contains the Flask application in a \n.py\n file, \n    and a few other files to help Heroku determine how to run the app\n    and what to install.\n\n\n\n\n\n\nmaster\n - this branch contains the content used to generate the documentation\n    and page content that is being hosted behind the Heroku attack sheep.\n    The documentation you are reading right now is from the master branch,\n    and was made with \nmkdocs\n.\n\n\n\n\n\n\nOn Heroku, we only have a single branch:\n\n\n\n\nmaster\n (Heroku) maps to \nheroku-pages\n (Github)\n\n\n\n\nRepo Layout\n\n\nLet's talk about the layout of the repository.\n\n\nIf you wish to build the site in order to deploy it to Heroku,\nyou should clone the \nmaster\n branch (preparing to make the\ncontent for your attack sheep-protected page):\n\n\n$ git clone -b master https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git\n$ cd github-heroku-attack-rabbits\n\n\n\n\nOnce you are \ninside\n the master branch, clone the repo again,\nbut this time clone the \nheroku-pages\n branch, and clone it \nto the \nsite/\n folder:\n\n\n$ git clone -b heroku-pages https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git site\n$ cd site\n\n\n\n\nNow you will want to set up the Heroku remote:\n\n\n$ heroku git:remote -a my-cool-project\n\n\n\n\nThe layout should now be:\n\n\nmy-cool-project-repo/   <-- my-cool-project repo pointing to master branch\n\n        docs/            \\\n            index.md      |\n            heroku.md     | <-- mkdocs files \n            ...           |     (can use any static content generator:\n                          |      pelican, sphinx, etc.)\n        mkdocs.yml       /\n\n        site/           <-- my-cool-project repo pointing to heroku-pages branch\n\n            Procfile           \\ \n            github.py           | <-- heroku python app files\n            requirements.txt    |     (can also use ruby, php, js, etc.)\n            runtime.txt         |     (can also use ruby, php, js, etc.)\n            ...                / \n\n            content/           \\   \n                index.html      | <-- static content hosted by Flask\n                sitemap.xml     | \n                ...            /  \n\n\n\n\nWorkflow\n\n\nOnce you have things set up according to the instructions and diagram above,\nyou're ready to run the push-to-deploy workflow and start running your secret\nsite on Heroku.",
            "title": "Initialize Repository: Branches"
        },
        {
            "location": "/repo/#initialize-git-repository",
            "text": "Let's talk through how a repository should be laid out \nif we're going to be hosting a Flask app on Heroku.",
            "title": "Initialize Git Repository"
        },
        {
            "location": "/repo/#branches",
            "text": "We will need a minimum of two branches. Here we specify\nthe names that these branches will have in your Github repo, which is different from the names of the branches on Heroku :  Branches on Github:    heroku-pages  - this branch contains the content that Heroku will host.\n    Specifically, it contains the Flask application in a  .py  file, \n    and a few other files to help Heroku determine how to run the app\n    and what to install.    master  - this branch contains the content used to generate the documentation\n    and page content that is being hosted behind the Heroku attack sheep.\n    The documentation you are reading right now is from the master branch,\n    and was made with  mkdocs .    On Heroku, we only have a single branch:   master  (Heroku) maps to  heroku-pages  (Github)",
            "title": "Branches"
        },
        {
            "location": "/repo/#repo-layout",
            "text": "Let's talk about the layout of the repository.  If you wish to build the site in order to deploy it to Heroku,\nyou should clone the  master  branch (preparing to make the\ncontent for your attack sheep-protected page):  $ git clone -b master https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git\n$ cd github-heroku-attack-rabbits  Once you are  inside  the master branch, clone the repo again,\nbut this time clone the  heroku-pages  branch, and clone it \nto the  site/  folder:  $ git clone -b heroku-pages https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git site\n$ cd site  Now you will want to set up the Heroku remote:  $ heroku git:remote -a my-cool-project  The layout should now be:  my-cool-project-repo/   <-- my-cool-project repo pointing to master branch\n\n        docs/            \\\n            index.md      |\n            heroku.md     | <-- mkdocs files \n            ...           |     (can use any static content generator:\n                          |      pelican, sphinx, etc.)\n        mkdocs.yml       /\n\n        site/           <-- my-cool-project repo pointing to heroku-pages branch\n\n            Procfile           \\ \n            github.py           | <-- heroku python app files\n            requirements.txt    |     (can also use ruby, php, js, etc.)\n            runtime.txt         |     (can also use ruby, php, js, etc.)\n            ...                / \n\n            content/           \\   \n                index.html      | <-- static content hosted by Flask\n                sitemap.xml     | \n                ...            /",
            "title": "Repo Layout"
        },
        {
            "location": "/repo/#workflow",
            "text": "Once you have things set up according to the instructions and diagram above,\nyou're ready to run the push-to-deploy workflow and start running your secret\nsite on Heroku.",
            "title": "Workflow"
        },
        {
            "location": "/flask/",
            "text": "Create a Flask App using Flask-Dance\n\n\nThis is the heart of the method.\n\n\nThe best thing to do here is just to walk you through the script.\n\n\nImport statements:\n\n\nimport os, json\nfrom os.path import join, isfile, isdir\nfrom werkzeug.contrib.fixers import ProxyFix\nfrom flask import Flask, redirect, url_for, send_from_directory\nfrom flask_dance.contrib.github import make_github_blueprint, github\n\n\n\n\nNote that flask-dance adds an OAuth login/callback route \nto your Flask app by creating a \n/login\n blueprint,\nmeaning all the OAuth stuff is just magically available \nvia \n/login\n.\n\n\nSet paths for static content:\n\n\nPROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))\nSTATIC_PATH = 'content'\n\n\n\n\nCreate and configure app. This requires confidential information\nfor the Github application you created, specifically the client\nID and client secret. These are at the very top of the page when\nyou visit your app's settings page.\n\n\nTo find this, after you log in, click your profile photo in the\nupper right > Settings > Developer Settings > OAuth Apps > click the \nname for your OAuth app.\n\n\napp = Flask(__name__)\n\n# this worked locally, but not on heroku\napp.wsgi_app = ProxyFix(app.wsgi_app)\n\napp.secret_key = os.environ.get(\"FLASK_SECRET_KEY\", \"9502861d41e8729c5cae3225920b1b46\")\n\napp.config[\"RESULT_STATIC_PATH\"] = STATIC_PATH #os.path.join(PROJECT_ROOT,STATIC_PATH)\napp.config[\"GITHUB_OAUTH_CLIENT_ID\"] = os.environ.get(\"GITHUB_OAUTH_CLIENT_ID\")\napp.config[\"GITHUB_OAUTH_CLIENT_SECRET\"] = os.environ.get(\"GITHUB_OAUTH_CLIENT_SECRET\")\n\n\n\n\nNow the magic happens: we use flask-dance to create a blueprint\nthat has methods and settings all ready to go for us to do the \nOAuth dance.\n\n\nmake_github_blueprint()\n is part of the contrib module of flask-dance.\nThere are several similar methods to generate blueprints for \nauthenticating with other APIs.\n\n\ngithub_bp = make_github_blueprint(\n                        client_id = os.environ.get('GITHUB_OAUTH_CLIENT_ID'),\n                        client_secret = os.environ.get('GITHUB_OAUTH_CLIENT_SECRET'),\n                        scope='read:org')\n\napp.register_blueprint(github_bp, url_prefix=\"/login\")\n\ncontents404 = \"<html><body><h1>Status: Error 404 Page Not Found</h1></body></html>\"\ncontents403 = \"<html><body><h1>Status: Error 403 Access Denied</h1></body></html>\"\ncontents200 = \"<html><body><h1>Status: OK 200</h1></body></html>\"\n\n\n\n\nDeal with the \n/\n route first:\n\n\n\n\nCheck if authorized, if not, redirect them to the login URL\n    (magical URLs taken care of magically by our \nmake_github_blueprint\n\n    function above)\n\n\nIf user is authorized (i.e., if they have gone through the OAuth \n    process and given their passsword to Github and been redirected \n    to your app with an OAuth token), then the next step is to \n    find out some information about them.\n\n\nUse the \ngithub\n object to call the Github API directly.\n\n\nDecide what to do from there.\n\n\n\n\n@app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='rainbow-mind-machine':\n\n\n\n\nThe next line is important to how the server works:\nif all of the criteria above have been met, we return \na static file:\n\n\n                return send_from_directory(STATIC_PATH, 'index.html')\n\n\n\n\nThis is normally \"bad practice,\" and numerous type A people \non the internet will tell you Flask should not be used for \nserving static files, and that you should use nginx etc., \nbut these fail to igonore the following:\n\n\n\n\nHeroku does not let you run or configure nginx\n\n\nFor crying out loud this example is about attack rabbits \n    stop taking everything so seriously\n\n\n\n\nNow that we've got that out of the way...\n\n\nHere's how we serve up static files. This is a total hack,\nbut it works. It takes any arbitrary path supplied by the \nuser, and attempts to find a corresponding file to serve up\non disk. \n\n\nIf the user passes a file, then that file is served up.\n\n\nIf the user passes a directory, then \nindex.html\n is served up.\n\n\nIf the user asks for a non-existent file, a 404 error is shown.\n\n\nIf the user is not allowed to view the content, they will face \nthe bowel-emptying terrors of the 403 error.\n\n\n@app.route('/<path:path>')\ndef catch_all(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    username = github.get(\"/user\").json()['login']\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='dcppc':\n\n                if(path==''):\n                    return send_from_directory(rsp, 'index.html')\n\n                elif(isdir(join(rsp,path))):\n                    return send_from_directory(join(rsp,path),'index.html')\n\n                elif(isfile(join(rsp,path))):\n                    return send_from_directory(rsp, path)\n\n                else:\n                    return contents404\n\n    return contents403\n\n\n\n\nLast, set a default 404 handler, and run the app:\n\n\n@app.errorhandler(404)\ndef oops(e):\n    return contents404\n\n\nif __name__ == \"__main__\":\n    app.run()",
            "title": "Create a Flask App using Flask-Dance"
        },
        {
            "location": "/flask/#create-a-flask-app-using-flask-dance",
            "text": "This is the heart of the method.  The best thing to do here is just to walk you through the script.  Import statements:  import os, json\nfrom os.path import join, isfile, isdir\nfrom werkzeug.contrib.fixers import ProxyFix\nfrom flask import Flask, redirect, url_for, send_from_directory\nfrom flask_dance.contrib.github import make_github_blueprint, github  Note that flask-dance adds an OAuth login/callback route \nto your Flask app by creating a  /login  blueprint,\nmeaning all the OAuth stuff is just magically available \nvia  /login .  Set paths for static content:  PROJECT_ROOT = os.path.dirname(os.path.realpath(__file__))\nSTATIC_PATH = 'content'  Create and configure app. This requires confidential information\nfor the Github application you created, specifically the client\nID and client secret. These are at the very top of the page when\nyou visit your app's settings page.  To find this, after you log in, click your profile photo in the\nupper right > Settings > Developer Settings > OAuth Apps > click the \nname for your OAuth app.  app = Flask(__name__)\n\n# this worked locally, but not on heroku\napp.wsgi_app = ProxyFix(app.wsgi_app)\n\napp.secret_key = os.environ.get(\"FLASK_SECRET_KEY\", \"9502861d41e8729c5cae3225920b1b46\")\n\napp.config[\"RESULT_STATIC_PATH\"] = STATIC_PATH #os.path.join(PROJECT_ROOT,STATIC_PATH)\napp.config[\"GITHUB_OAUTH_CLIENT_ID\"] = os.environ.get(\"GITHUB_OAUTH_CLIENT_ID\")\napp.config[\"GITHUB_OAUTH_CLIENT_SECRET\"] = os.environ.get(\"GITHUB_OAUTH_CLIENT_SECRET\")  Now the magic happens: we use flask-dance to create a blueprint\nthat has methods and settings all ready to go for us to do the \nOAuth dance.  make_github_blueprint()  is part of the contrib module of flask-dance.\nThere are several similar methods to generate blueprints for \nauthenticating with other APIs.  github_bp = make_github_blueprint(\n                        client_id = os.environ.get('GITHUB_OAUTH_CLIENT_ID'),\n                        client_secret = os.environ.get('GITHUB_OAUTH_CLIENT_SECRET'),\n                        scope='read:org')\n\napp.register_blueprint(github_bp, url_prefix=\"/login\")\n\ncontents404 = \"<html><body><h1>Status: Error 404 Page Not Found</h1></body></html>\"\ncontents403 = \"<html><body><h1>Status: Error 403 Access Denied</h1></body></html>\"\ncontents200 = \"<html><body><h1>Status: OK 200</h1></body></html>\"  Deal with the  /  route first:   Check if authorized, if not, redirect them to the login URL\n    (magical URLs taken care of magically by our  make_github_blueprint \n    function above)  If user is authorized (i.e., if they have gone through the OAuth \n    process and given their passsword to Github and been redirected \n    to your app with an OAuth token), then the next step is to \n    find out some information about them.  Use the  github  object to call the Github API directly.  Decide what to do from there.   @app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='rainbow-mind-machine':  The next line is important to how the server works:\nif all of the criteria above have been met, we return \na static file:                  return send_from_directory(STATIC_PATH, 'index.html')  This is normally \"bad practice,\" and numerous type A people \non the internet will tell you Flask should not be used for \nserving static files, and that you should use nginx etc., \nbut these fail to igonore the following:   Heroku does not let you run or configure nginx  For crying out loud this example is about attack rabbits \n    stop taking everything so seriously   Now that we've got that out of the way...  Here's how we serve up static files. This is a total hack,\nbut it works. It takes any arbitrary path supplied by the \nuser, and attempts to find a corresponding file to serve up\non disk.   If the user passes a file, then that file is served up.  If the user passes a directory, then  index.html  is served up.  If the user asks for a non-existent file, a 404 error is shown.  If the user is not allowed to view the content, they will face \nthe bowel-emptying terrors of the 403 error.  @app.route('/<path:path>')\ndef catch_all(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    username = github.get(\"/user\").json()['login']\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='dcppc':\n\n                if(path==''):\n                    return send_from_directory(rsp, 'index.html')\n\n                elif(isdir(join(rsp,path))):\n                    return send_from_directory(join(rsp,path),'index.html')\n\n                elif(isfile(join(rsp,path))):\n                    return send_from_directory(rsp, path)\n\n                else:\n                    return contents404\n\n    return contents403  Last, set a default 404 handler, and run the app:  @app.errorhandler(404)\ndef oops(e):\n    return contents404\n\n\nif __name__ == \"__main__\":\n    app.run()",
            "title": "Create a Flask App using Flask-Dance"
        },
        {
            "location": "/flask_auth_github/",
            "text": "Authenticate Users on Github Membership\n\n\nFor the sake of simplicity, will just demonstrate how this \nworks for a single route, but you can combine different \nrules into multiple routes to provide access to different\npeople on different parts of a site.\n\n\nHere is the relevant method that serves up \nindex.html\n \nif the user is authenticated:\n\n\n@app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user\")\n\n    if resp.ok:\n        return send_from_directory(STATIC_PATH, 'index.html')\n\n    return contents403",
            "title": "Authenticate users based on Github membership only"
        },
        {
            "location": "/flask_auth_github/#authenticate-users-on-github-membership",
            "text": "For the sake of simplicity, will just demonstrate how this \nworks for a single route, but you can combine different \nrules into multiple routes to provide access to different\npeople on different parts of a site.  Here is the relevant method that serves up  index.html  \nif the user is authenticated:  @app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user\")\n\n    if resp.ok:\n        return send_from_directory(STATIC_PATH, 'index.html')\n\n    return contents403",
            "title": "Authenticate Users on Github Membership"
        },
        {
            "location": "/flask_auth_org/",
            "text": "Authenticate Users on Organization or Team Membership\n\n\nHere is how we can make access to a given page or route\nconditional on membership in an organization (in this \nexample, membership in the \nrainbow-mind-machine\n organization\nis required for access):\n\n\n@app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='rainbow-mind-machine':\n                return send_from_directory(STATIC_PATH, 'index.html')",
            "title": "Authenticate users based on organization or team membership"
        },
        {
            "location": "/flask_auth_org/#authenticate-users-on-organization-or-team-membership",
            "text": "Here is how we can make access to a given page or route\nconditional on membership in an organization (in this \nexample, membership in the  rainbow-mind-machine  organization\nis required for access):  @app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user/orgs\")\n    if resp.ok:\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']=='rainbow-mind-machine':\n                return send_from_directory(STATIC_PATH, 'index.html')",
            "title": "Authenticate Users on Organization or Team Membership"
        },
        {
            "location": "/flask_auth_other/",
            "text": "Authenticate Users on Other Criteria\n\n\nSuppose we wanted to do something silly like restrict\naccess to a page to users with Github handles that were \nbetween 5 and 7 letters.\n\n\nHere is the relevant method that serves up \nindex.html\n \nif the user's Github handle is 5-7 letters long:\n\n\n@app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user\")\n\n    if resp.ok:\n        username = resp.json()['login']\n        if len(username)>=5 and len(username)<=7:\n            return send_from_directory(STATIC_PATH, 'index.html')\n\n    return contents403",
            "title": "Authenticate users based on some other criteria"
        },
        {
            "location": "/flask_auth_other/#authenticate-users-on-other-criteria",
            "text": "Suppose we wanted to do something silly like restrict\naccess to a page to users with Github handles that were \nbetween 5 and 7 letters.  Here is the relevant method that serves up  index.html  \nif the user's Github handle is 5-7 letters long:  @app.route('/')\ndef index():\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    resp = github.get(\"/user\")\n\n    if resp.ok:\n        username = resp.json()['login']\n        if len(username)>=5 and len(username)<=7:\n            return send_from_directory(STATIC_PATH, 'index.html')\n\n    return contents403",
            "title": "Authenticate Users on Other Criteria"
        },
        {
            "location": "/flask_auth_portions/",
            "text": "Authenticate Different Users on Different Portions of Site\n\n\nNOTE: if you are authenticating using membership on a team, you will need the \nteam id of the team you are interested in authenticating against.\n\n\nFor this example, let's expand the routes we're looking at \na bit more.\n\n\nSuppose we have two folders, \nteam_only\n and \norg_only\n.\n\n\nThe \nteam_only\n folder should only be accessible to your team, \nTeam Gold\n.\n\n\nThe \norg_only\n folder should only be accessible to your organization, \nColorful Colors\n.\n\n\nThe main site (i.e., all other files) should be publicly accessible.\n\n\n@app.route('/')\ndef index():\n    return send_from_directory(STATIC_PATH, 'index.html')\n\n\n@app.route('/team_only/<path:path>')\ndef team_gold(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n\n    resp = github.get(\"/user\")\n    if resp.ok:\n        username = resp.json()['login']\n\n        team_id = 'XXXXX'\n\n        resp = github.get(\"/teams/%s/members/%s\"%( team_id, username ))\n        if resp.code==204:\n            team_gold_dir = os.path.join(STATIC_PATH, 'team_only')\n            return send_from_directory(team_gold_dir, 'index.html')\n    return contents403\n\n\n@app.route('/org_only/<path:path>')\ndef team_gold(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n\n    resp = github.get(\"/user\")\n    if resp.ok:\n\n        my_org = 'XXXXXXXX'\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']==my_org:\n                color_org_dir = os.path.join(STATIC_PATH, 'org_only')\n                return send_from_directory(color_org_dir, 'index.html')\n    return contents403",
            "title": "Protection portions of the site"
        },
        {
            "location": "/flask_auth_portions/#authenticate-different-users-on-different-portions-of-site",
            "text": "NOTE: if you are authenticating using membership on a team, you will need the \nteam id of the team you are interested in authenticating against.  For this example, let's expand the routes we're looking at \na bit more.  Suppose we have two folders,  team_only  and  org_only .  The  team_only  folder should only be accessible to your team,  Team Gold .  The  org_only  folder should only be accessible to your organization,  Colorful Colors .  The main site (i.e., all other files) should be publicly accessible.  @app.route('/')\ndef index():\n    return send_from_directory(STATIC_PATH, 'index.html')\n\n\n@app.route('/team_only/<path:path>')\ndef team_gold(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n\n    resp = github.get(\"/user\")\n    if resp.ok:\n        username = resp.json()['login']\n\n        team_id = 'XXXXX'\n\n        resp = github.get(\"/teams/%s/members/%s\"%( team_id, username ))\n        if resp.code==204:\n            team_gold_dir = os.path.join(STATIC_PATH, 'team_only')\n            return send_from_directory(team_gold_dir, 'index.html')\n    return contents403\n\n\n@app.route('/org_only/<path:path>')\ndef team_gold(path):\n\n    if not github.authorized:\n        return redirect(url_for(\"github.login\"))\n\n    rsp = app.config[\"RESULT_STATIC_PATH\"]\n\n    resp = github.get(\"/user\")\n    if resp.ok:\n\n        my_org = 'XXXXXXXX'\n\n        all_orgs = resp.json()\n        for org in all_orgs:\n            if org['login']==my_org:\n                color_org_dir = os.path.join(STATIC_PATH, 'org_only')\n                return send_from_directory(color_org_dir, 'index.html')\n    return contents403",
            "title": "Authenticate Different Users on Different Portions of Site"
        },
        {
            "location": "/flask_local/",
            "text": "Testing Flask App Locally\n\n\nWe set up the Github App to use a callback of \nhttps://localhost:5000/login/github/authorized\n\nso that we could test the app locally. Now it is time to test the app locally.\n\n\nThe application needs access to your Github app id and token. Those are provided \nvia the \nGITHUB_OAUTH_CLIENT_{ID,SECRET}\n environment variables. Set these \nwhen you run the actual python command to run the server:\n\n\n$ GITHUB_OAUTH_CLIENT_ID=\"xxxxxxx\" \\\n  GITHUB_OAUTH_CLIENT_SECRET=\"xxxxxxx\" \\\n  OAUTHLIB_INSECURE_TRANSPORT=true \\\n  python github.py\n\n\n\n\nThis runs the Flask server on port 5000, where it will wait for a visitor.\nThe way we have our application written in this example, the main \n/\n route\nwill redirect the user to a Github login screen immediately, but you could \nalso present the user with a friendly welcome page when they go to \n/\n, \nand only redirect them to the Github login prompt when they visit a \nURL like \n/login\n or \n/auth\n.\n\n\nOnce you run the above command, open the following URL in your browser:\n\n\nhttp://localhost:5000/\n\n\n\n\nNOTE: Make sure you are logged out of Github and that you clear your cookies \nif you are already logged in as one user and wish to authenticate as another.\nThe login is \nvery\n persistent so you may need to close and re-open your browser.\n\n\nVisiting the address above will result in your being redirected to a Github\nlogin page. Once you login, Github will redirect the user back to the \ngithub-heroku-attack-rabbits application with a token that the application \ncan use to perform actions on behalf of the user.\n\n\nNext Step?\n\n\nIf the app works, the next step is to deploy to Heroku.",
            "title": "Test Flask App Locally"
        },
        {
            "location": "/flask_local/#testing-flask-app-locally",
            "text": "We set up the Github App to use a callback of  https://localhost:5000/login/github/authorized \nso that we could test the app locally. Now it is time to test the app locally.  The application needs access to your Github app id and token. Those are provided \nvia the  GITHUB_OAUTH_CLIENT_{ID,SECRET}  environment variables. Set these \nwhen you run the actual python command to run the server:  $ GITHUB_OAUTH_CLIENT_ID=\"xxxxxxx\" \\\n  GITHUB_OAUTH_CLIENT_SECRET=\"xxxxxxx\" \\\n  OAUTHLIB_INSECURE_TRANSPORT=true \\\n  python github.py  This runs the Flask server on port 5000, where it will wait for a visitor.\nThe way we have our application written in this example, the main  /  route\nwill redirect the user to a Github login screen immediately, but you could \nalso present the user with a friendly welcome page when they go to  / , \nand only redirect them to the Github login prompt when they visit a \nURL like  /login  or  /auth .  Once you run the above command, open the following URL in your browser:  http://localhost:5000/  NOTE: Make sure you are logged out of Github and that you clear your cookies \nif you are already logged in as one user and wish to authenticate as another.\nThe login is  very  persistent so you may need to close and re-open your browser.  Visiting the address above will result in your being redirected to a Github\nlogin page. Once you login, Github will redirect the user back to the \ngithub-heroku-attack-rabbits application with a token that the application \ncan use to perform actions on behalf of the user.",
            "title": "Testing Flask App Locally"
        },
        {
            "location": "/flask_local/#next-step",
            "text": "If the app works, the next step is to deploy to Heroku.",
            "title": "Next Step?"
        },
        {
            "location": "/flask_heroku/",
            "text": "Deploying to Heroku\n\n\nOnce we have debugged the Flask app and we are happy with it,\nwe are ready to deploy it to Heroku. \n\n\nRepository Setup\n\n\nTo do this, you should set up your repo as follows:\n\n\nClone the repo:\n\n\n$ git clone https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git\n\n\n\n\nThe repo has the following structure:\n\n\ngithub-heroku-attack-rabbits/\n            LICENSE\n            README.md\n            mkdocs.yml\n            docs/\n                index.md\n                ...\n            mkdocs-material/\n                ...\n\n\n\n\nNow, inside the repo, clone the repo again,\nbut this time clone the \nheroku-pages\n branch\nto the \nsite/\n directory:\n\n\n$ cd github-heroku-attack-rabbits/\n$ git clone -b heroku-pages https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git site\n\n\n\n\nHeroku Deploy Process\n\n\nTo deploy content to Heroku, we add our Heroku project as a git remote \n(see the \nheroku\n page for how to do that) and then push to \nto the master branch of the heroku remote git repo. Changes are pulled \nin by Heroku and the app is restarted each time you run \ngit push\n.\n\n\nWe walk through the steps below.\n\n\nHeroku Login\n\n\nFrom the \nsite/\n directory containing the contents of the \nheroku-pages\n branch,\nthat is, containing the Python flask app, log in to Heroku:\n\n\n$ heroku login\n\n\n\n\nAdd Heroku Remote to \nheroku-pages\n Branch\n\n\nNow have Heroku add the proper git remote address:\n\n\n$ heroku git:remote -a <heroku-app-name>\n\n\n\n\nNow you're ready to deploy to Heroku. \n\n\nDeploy to Heroku\n\n\nDouble check your app is ready, then deploy:\n\n\n$ git push heroku heroku-pages:master\n\n\n\n\nThis will push the local branch \nheroku-pages\n to\nthe remote branch \nmaster\n on the \nheroku\n remote.\nThis should begin a pre-commit hook where Heroku\ncompiles your Python app. You should get the green\nlight, if you tested your app locally and everything\nwas good to go.\n\n\nCheck Your Heroku App\n\n\nYour Heroku app will be available at \n\n\nhttps://<heroku-app-name>.herokuapp.com\n\n\n\n\nYou should see your Python flask app\nshow up shortly.",
            "title": "Deploying Flask App to Heroku"
        },
        {
            "location": "/flask_heroku/#deploying-to-heroku",
            "text": "Once we have debugged the Flask app and we are happy with it,\nwe are ready to deploy it to Heroku.",
            "title": "Deploying to Heroku"
        },
        {
            "location": "/flask_heroku/#repository-setup",
            "text": "To do this, you should set up your repo as follows:  Clone the repo:  $ git clone https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git  The repo has the following structure:  github-heroku-attack-rabbits/\n            LICENSE\n            README.md\n            mkdocs.yml\n            docs/\n                index.md\n                ...\n            mkdocs-material/\n                ...  Now, inside the repo, clone the repo again,\nbut this time clone the  heroku-pages  branch\nto the  site/  directory:  $ cd github-heroku-attack-rabbits/\n$ git clone -b heroku-pages https://git.charlesreid1.com/charlesreid1/github-heroku-attack-rabbits.git site",
            "title": "Repository Setup"
        },
        {
            "location": "/flask_heroku/#heroku-deploy-process",
            "text": "To deploy content to Heroku, we add our Heroku project as a git remote \n(see the  heroku  page for how to do that) and then push to \nto the master branch of the heroku remote git repo. Changes are pulled \nin by Heroku and the app is restarted each time you run  git push .  We walk through the steps below.",
            "title": "Heroku Deploy Process"
        },
        {
            "location": "/flask_heroku/#heroku-login",
            "text": "From the  site/  directory containing the contents of the  heroku-pages  branch,\nthat is, containing the Python flask app, log in to Heroku:  $ heroku login",
            "title": "Heroku Login"
        },
        {
            "location": "/flask_heroku/#add-heroku-remote-to-heroku-pages-branch",
            "text": "Now have Heroku add the proper git remote address:  $ heroku git:remote -a <heroku-app-name>  Now you're ready to deploy to Heroku.",
            "title": "Add Heroku Remote to heroku-pages Branch"
        },
        {
            "location": "/flask_heroku/#deploy-to-heroku",
            "text": "Double check your app is ready, then deploy:  $ git push heroku heroku-pages:master  This will push the local branch  heroku-pages  to\nthe remote branch  master  on the  heroku  remote.\nThis should begin a pre-commit hook where Heroku\ncompiles your Python app. You should get the green\nlight, if you tested your app locally and everything\nwas good to go.",
            "title": "Deploy to Heroku"
        },
        {
            "location": "/flask_heroku/#check-your-heroku-app",
            "text": "Your Heroku app will be available at   https://<heroku-app-name>.herokuapp.com  You should see your Python flask app\nshow up shortly.",
            "title": "Check Your Heroku App"
        },
        {
            "location": "/custom_domains/",
            "text": "Custom Domains\n\n\nIf you want to use a custom domain:\n\n\n\n\nSet up custom domain using Heroku command line interface\n\n\nThis will set up a DNS subdomain specifically for your app\n\n\nPoint your DNS records to the Heroku DNS subdomain\n\n\n\n\nThis also introduces complications with HTTP vs HTTPS:\nOAuth must happen over HTTPS (required by protocol).\nBut you the user can control your domain and create \nSSL certificates for it, but Heroku is hosting the app.\n\n\nYou have two options: the free option, and the pay option.\n\n\nThe pay option:\n For $7/mo you can upgrade to hobby nodes,\nwhich allows you to give Heroku permission to create an SSL \ncertificate for your domain. This is the easiest solution\nand requires zero setup, zero certificate management.\n\n\nThe free option:\n You can have your domain (HTTP only)\nforward to Heroku (HTTPS can't be forwarded - that's \nkey\n). \nWhen you hit the Heroku domain, it will log the user in to Github. \nWhen the user logs in successfully, Github will redirect them to \nthe callback URL. This callback URL \nMUST\n be HTTPS, so it cannot \nredirect back to your (HTTP-only) custom domain.\n\n\nThat means the userr will, after authenticating with Github,\nalways be redirected to \nhttps://my-cool-app.herokuapp.com\n\nand never \nhttp://my-cool-custom-domain-that-cannot-be-used-as-a-callback-because-it-is-https-only.com\n.\n\n\nThe paid option is much, much simpler in the end \nand will save you $7/mo in setup time alone.",
            "title": "Custom Domains"
        },
        {
            "location": "/custom_domains/#custom-domains",
            "text": "If you want to use a custom domain:   Set up custom domain using Heroku command line interface  This will set up a DNS subdomain specifically for your app  Point your DNS records to the Heroku DNS subdomain   This also introduces complications with HTTP vs HTTPS:\nOAuth must happen over HTTPS (required by protocol).\nBut you the user can control your domain and create \nSSL certificates for it, but Heroku is hosting the app.  You have two options: the free option, and the pay option.  The pay option:  For $7/mo you can upgrade to hobby nodes,\nwhich allows you to give Heroku permission to create an SSL \ncertificate for your domain. This is the easiest solution\nand requires zero setup, zero certificate management.  The free option:  You can have your domain (HTTP only)\nforward to Heroku (HTTPS can't be forwarded - that's  key ). \nWhen you hit the Heroku domain, it will log the user in to Github. \nWhen the user logs in successfully, Github will redirect them to \nthe callback URL. This callback URL  MUST  be HTTPS, so it cannot \nredirect back to your (HTTP-only) custom domain.  That means the userr will, after authenticating with Github,\nalways be redirected to  https://my-cool-app.herokuapp.com \nand never  http://my-cool-custom-domain-that-cannot-be-used-as-a-callback-because-it-is-https-only.com .  The paid option is much, much simpler in the end \nand will save you $7/mo in setup time alone.",
            "title": "Custom Domains"
        }
    ]
}